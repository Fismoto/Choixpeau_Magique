# coding: utf_8

'''
Codé par : Octave FORTUN, Milo MONTAGNE, Pierrick LEFEVRE

Projet NSI 3 "Choixpeau Magique", partie II

IHM du Choixpeau Magique, utilise l'agorythme des KPPV codé précédemment.

Licence : CC-BY-NC-SA

github : https://github.com/Fismoto/Choixpeau_Magique
'''
# Importation des modules :
from math import sqrt
from browser import document, html
from kPPV_MONTAGNE_LEFEVRE_FORTUN import CARACTERISTICS, csv_dict_import, \
    euclidian_distance, knn_house, knn_print, poudlard_characters

CLIENT_PROFILE = {}
for caracteristic in CARACTERISTICS:
    CLIENT_PROFILE[caracteristic] = 0

# Définition des fonctions :
def tuple_values(values : str):
    '''
    Transforme un str en tuple (pour l'import des questions)
    Entrées :
        - values, str de la forme "0, -1, +2, +1"
    Sorties :
        - tuple de la forme (0, -1, 2, 1)
    '''
    # Préconditions:
    assert type(values) == str, "L'entrée de la fonction doit être un str."
    list_values =[]
    for number in values.split(', '):
        list_values.append(int(number))
    return tuple(list_values)

def space(nb_lines: int):
    '''
    Saute autant de lignes qu'indiqué en paramètre.

    Entrées :
        - nb_lines, entier positif
    Sorties :
        - pas de sorties (procédure d'affichage)
    '''
    # Préconditions:
    assert type(nb_lines) == int and nb_lines >= 0, \
        "On saute un nombre entier positif de lignes"

    for i in range(nb_lines):
        document <= html.BR()

def button_1_clicked(ev):
    '''
    Ce qu'il se passe quand on clique sur le bouton 1.

    Entrées :
        - ev, l'évènement mis dans le .bind() du bouton
    Sorties :
        - pas de sorties
    '''
    document['bouton_1'].textContent = "Cliqué"                
                
def button_2_clicked(ev):
    '''
    Idem pour le bouton 2.
    '''
    document['bouton_2'].textContent = "Cliqué"
                
def button_3_clicked(ev):
    '''
    Idem pour le bouton 3.
    '''
    document['bouton_3'].textContent = "Cliqué"

# Importation des questions :
questions_tab = csv_dict_import("Questions.csv")
for i in range(len(questions_tab)):
    for key in questions_tab[i]:
        if key in {"Value 1", "Value 2", "Value 3"}:
            questions_tab[i][key] = tuple_values(questions_tab[i][key])

# Création des éléments HTML :
document <= html.H1("Question :", id='printed_question')             
document <= html.BUTTON("Bouton_1", id="bouton_1")
space(2)
document <= html.BUTTON("Bouton_2", id="bouton_2")
space(2)
document <= html.BUTTON("Bouton_3", id="bouton_3")

# .bind des boutons :
document['bouton_1'].bind("click", button_1_clicked)
document['bouton_2'].bind("click", button_2_clicked)
document['bouton_3'].bind("click", button_3_clicked)

# Pour nos tests :
space(2)
document <= html.H4("Testez la questions / réponse à afficher :", id="test_questions")
for question in questions_tab:
    for key in question:
        document <= html.P(question[key])
    space(2)