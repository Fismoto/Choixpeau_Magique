# coding: utf_8

'''
Codé par : Octave FORTUN, Milo MONTAGNE, Pierrick LEFEVRE

Projet NSI 3 "Choixpeau Magique", partie II

IHM du Choixpeau Magique, utilise l'agorythme des KPPV codé précédemment.

Licence : CC-BY-NC-SA

github : https://github.com/Fismoto/Choixpeau_Magique
'''
# Importation des modules :
from math import sqrt
from browser import document, html
from kPPV_MONTAGNE_LEFEVRE_FORTUN import CARACTERISTICS, csv_dict_import, \
    euclidian_distance, knn_house, knn_str, poudlard_characters

# Variables globales :
CLIENT_PROFILE = {}
for caracteristic in CARACTERISTICS:
    CLIENT_PROFILE[caracteristic] = 0

INDEX_QUESTION = 0

ALL_ID = []

NB_SPACE = 0

K = 5

CHARACTERS = poudlard_characters


# Définition des fonctions (hors utilisation des boutons) :
def delete_all():
    '''
    Supprimme tous les éléments HTML de la page, et les supprimme de la liste ALL_ID.
    Pas d'entrée ni sortie (procédure).
    '''
    for id in ALL_ID:
        del document[id]

    ALL_ID.clear()

def final_print(profile: dict, characters_data_base: list, k_client=K):
    '''
    Affichage final de la page (quand l'utilisateur clique sur le dernier bouton).
    Efface le contenu de la page et affiche la maison du personnage, en utilisant les KPPV

    Entrées :
        - profile : dictionnaire contenant les valeurs des caractéristiques de l'utilisateur
        - characters_data_base : table, liste de dictionnaires où chaque dictionnaire correspond à un personnage
        - k_client : entier, valeur par défault : la constante K

    Pas de sortie, procédure d'affichage
    '''
    # Préconditions :
    assert type(profile) == dict, \
        "Le nouveau personnage doit être sous forme de dictionnaire."

    assert type(characters_data_base) == list, \
        "La base de donnée des personnages doit être une liste de dictionnaires."

    assert type(k_client) == int and k_client > 0, \
        "Le k doit être un entier positif." 

    delete_all()

    house, k_n_neighbors = knn_house(characters_data_base, profile, CARACTERISTICS, k=k_client)
    document <= html.P(knn_str(profile, k_n_neighbors, house))

def space(nb_lines: int):
    '''
    Saute autant de lignes qu'indiqué en paramètre.

    Entrées :
        - nb_lines, entier positif
    Sorties :
        - pas de sorties (procédure d'affichage)
    '''
    # Préconditions:
    assert type(nb_lines) == int and nb_lines >= 0, \
        "On saute un nombre entier positif de lignes"

    global NB_SPACE

    for i in range(nb_lines):
        NB_SPACE += 1
        space_id = f"space_{NB_SPACE}"
        document <= html.BR(id=space_id)
        # Pour pouvoir supprimmer toutes les balises <br> à la fin : (voir fonction final_print())
        ALL_ID.append(space_id)


# Définition des fonctions liées aux boutons :
def bind_buttons(buttons: list, function, event='click'):
    '''
    .bind() des 3 boutons réponses, en une fonction.

    Entrées : 
        - event : chaîne de caractères, 
        évènement qui appelle la fonction function (prise en paramètre)
        - function : fonction appellée lors de l'évènement event (pris en paramètre)
    '''
    # Préconditions:
    assert type(buttons) == list or type(buttons) == tuple, \
        "Les boutons à .bind() doivent être entrés sous forme de liste ou de tuple."
    assert type(event) == str, \
        "L'évènement doit être une chaîne de caractères (ex : 'click')"

    for nb in range(1, 4):
        document[f'button_{nb}'].bind(event, function)


def create_questions(questions: list, function_called):
    '''
    Crée tous les éléments HTML du questionnaire.

    Entrées :
        - questions, liste de dictionnaires 
        où chaque dictionnaire correspond à une question 
        et est de la forme : {'Question': 'question', \
                            'Answer 1': 'réponse', 'Value 1': 'tuple_de_valeurs', \
                            'Answer 2': 'réponse', 'Value 2': 'tuple_de_valeurs', \
                            'Answer 2': 'réponse', 'Value 2': 'tuple_de_valeurs'}
    
    Pas de sortie, procédure d'affichage.
    '''
    document <= html.H2(questions[INDEX_QUESTION]['Question'], id='printed_question')
    ALL_ID.append('printed_question')

    response_buttons = [f"button_{i}" for i in range(1, 4)]
    for i in range(3):            
        document <= html.BUTTON(questions[INDEX_QUESTION][f'Answer {i + 1}'], id=response_buttons[i])
        space(2)
        ALL_ID.append(response_buttons[i])

    bind_buttons(response_buttons, function=function_called, event='click')

def tuple_values(values : str):
    '''
    Transforme un str en tuple (pour l'import des questions)
    Entrées :
        - values, str de la forme "0, -1, +2, +1"
    Sorties :
        - tuple de la forme (0, -1, 2, 1)
    '''
    # Préconditions:
    assert type(values) == str, "L'entrée de la fonction doit être un str."
    list_values = []
    for number in values.split(', '):
        list_values.append(int(number))
    return tuple(list_values)

# Importation des questions :
QUESTIONS_TAB = csv_dict_import("Questions.csv")
for i in range(len(QUESTIONS_TAB)):
    for key in QUESTIONS_TAB[i]:
        if key in {"Value 1", "Value 2", "Value 3"}:
            QUESTIONS_TAB[i][key] = tuple_values(QUESTIONS_TAB[i][key])
# (On est obligé de mettre cette table en variable globale pour l'utiliser dans la fonction button_clicked)

def update_all(index_question: int, questions: int, characters_data_base: int, k=K):
    '''
    Met à jour l'affichage de la question et des boutons
    
    Entrées :
        - index_question, entier, \
        indice de la question à laquelle l'utilisateur est rendu
    
    Pas de sorties, procédure d'affichage.
    '''
    if index_question < len(questions):
        document['printed_question'].textContent = questions[index_question]['Question']        
        for nb in range(1, 4):
            document[f'button_{nb}'].textContent = questions[index_question][f'Answer {nb}']

    else:
        final_print(CLIENT_PROFILE, characters_data_base, k_client=k)
        
def response_button_clicked(ev):
    '''
    Changement de l'affichage et modification du profil lorsqu'on clique sur un bouton.
    On récupère l'id du bouton qui est cliqué avec l'objet pris en paramêtre ev.
    
    Entrées :
        - ev, paramètre par défaut et obligatoire pour les .bind()
    Sorties :
        - Pas de sortie, procédure d'affichage.
    '''
    global INDEX_QUESTION

    # Modification du profil client :

    nb_button_clicked = ev.target.id[-1:]
    added_values = QUESTIONS_TAB[INDEX_QUESTION][f'Value {nb_button_clicked}']

    for i, caracteristic in enumerate(CLIENT_PROFILE):
        if CLIENT_PROFILE[caracteristic] + added_values[i] > 0 and CLIENT_PROFILE[caracteristic] + added_values[i] < 9:
            CLIENT_PROFILE[caracteristic] += added_values[i]

    # Changement de l'affichage :
    INDEX_QUESTION += 1
    update_all(INDEX_QUESTION, questions=QUESTIONS_TAB, characters_data_base=poudlard_characters, k=K)

def launch_quizz(ev):
    '''
    Supprimme tout le contenu de la page
    puis lance le questionnaire.

    Entrées :
        - ev, paramètre par défaut et obligatoire pour les .bind()
    Sorties :
        - Pas de sortie, procédure d'affichage.
    '''
    delete_all()

    create_questions(questions=QUESTIONS_TAB, function_called=response_button_clicked)

def page_beginning():
    '''
    Premier affichage de la page, 
    création d'un bouton qui appelle la fonction launch_quizz().

    Pas d'entrée ni sortie, procédure d'affichage.
    '''
    first_sentence = "Salut, jeune bipède, aurais-tu quelques minutes à m'accorder ? \n\
                        Je suis le choixpeau magique, répond à mes questions et tu connaitras ta maison."

    document <= html.H1(first_sentence, id='first_sentence')
    document <= html.BUTTON("C'est parti !", id='first_button')

    ALL_ID.append('first_sentence')
    ALL_ID.append('first_button')

    document['first_button'].bind("click", launch_quizz)

# Affichage de la page :
page_beginning()