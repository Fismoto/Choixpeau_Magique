# coding: utf_8

'''
Codé par : Octave FORTUN, Milo MONTAGNE, Pierrick LEFEVRE

Projet NSI 3 "Choixpeau Magique", partie II

IHM du Choixpeau Magique, utilise l'agorythme des KPPV codé précédemment.

Licence : CC-BY-NC-SA

github : https://github.com/Fismoto/Choixpeau_Magique
'''
# Importation des modules :
from math import sqrt
from browser import document, html
from kPPV_MONTAGNE_LEFEVRE_FORTUN import CARACTERISTICS, csv_dict_import, \
    euclidian_distance, knn_house, knn_str, poudlard_characters

# Variables globales :
CLIENT_PROFILE = {}
for caracteristic in CARACTERISTICS:
    CLIENT_PROFILE[caracteristic] = 0

INDEX_QUESTION = 0

ALL_ID = []

NB_SPACE = 0


# Définition des fonctions (hors utilisation des boutons) :
def tuple_values(values : str):
    '''
    Transforme un str en tuple (pour l'import des questions)
    Entrées :
        - values, str de la forme "0, -1, +2, +1"
    Sorties :
        - tuple de la forme (0, -1, 2, 1)
    '''
    # Préconditions:
    assert type(values) == str, "L'entrée de la fonction doit être un str."
    list_values =[]
    for number in values.split(', '):
        list_values.append(int(number))
    return tuple(list_values)

def space(nb_lines: int):
    '''
    Saute autant de lignes qu'indiqué en paramètre.

    Entrées :
        - nb_lines, entier positif
    Sorties :
        - pas de sorties (procédure d'affichage)
    '''
    # Préconditions:
    assert type(nb_lines) == int and nb_lines >= 0, \
        "On saute un nombre entier positif de lignes"

    global NB_SPACE

    for i in range(nb_lines):
        NB_SPACE += 1
        space_id = f"space_{NB_SPACE}"
        document <= html.BR(id=space_id)
        # Pour pouvoir supprimmer toutes les balises <br> à la fin : (voir fonction final_print())
        ALL_ID.append(space_id)

def final_print(profile):
    '''
    Affichage final de la page (quand l'utilisateur clique sur le dernier bouton).
    Efface le contenu de la page et affiche la maison du personnage, en utilisant les KPPV

    Entrées :
        - profile, dictionnaire contenant les valeurs des caractéristiques de l'utilisateur

    Pas de sortie, procédure d'affichage
    '''
    # Préconditions :
    assert type(profile) == dict, \
        "Le nouveau personnage doit être sous forme de dictionnaire."

    for id in ALL_ID:
        del document[id]

    house, k_n_neighbors = knn_house(poudlard_characters, profile, CARACTERISTICS, k=5)
    document <= html.P(knn_str(profile, k_n_neighbors, house))

# Définition des fonctions liées aux boutons :
def create_all(questions: list):
    '''
    Crée tous les éléments HTML du questionnaire.

    Entrées :
        - questions, liste de dictionnaires 
        où chaque dictionnaire correspond à une question 
        et est de la forme : {'Question': 'question', \
                            'Answer 1': 'réponse', 'Value 1': 'tuple_de_valeurs', \
                            'Answer 2': 'réponse', 'Value 2': 'tuple_de_valeurs', \
                            'Answer 2': 'réponse', 'Value 2': 'tuple_de_valeurs'}
    
    Pas de sortie, procédure d'affichage.
    '''
    first_sentence = "Salut, jeune bipède ! Bienvenue dans le questionnaire du choixpeau magique !  Première question :"
    document <= html.H1(first_sentence, id='first_sentence')
    document <= html.H2(questions[INDEX_QUESTION]['Question'], id='printed_question')
    ALL_ID.append('first_sentence')
    ALL_ID.append('printed_question')
    for i in range(1, 4):            
        document <= html.BUTTON(questions[INDEX_QUESTION][f'Answer {i}'], id=f'button_{i}')
        space(2)
        ALL_ID.append('button_{i}')

def update_all(index_question: int, questions):
    '''
    Met à jour l'affichage de la question et des boutons
    
    Entrées :
        - index_question, entier, \
        indice de la question à laquelle l'utilisateur est rendu
    
    Pas de sorties, procédure d'affichage.
    '''
    if index_question < len(questions):
        if index_question == 1:
            del document['first_sentence']
            del ALL_ID[ALL_ID.index('first_sentence')]
        document['printed_question'].textContent = questions[index_question]['Question']
        for nb in range(1, 4):
            document[f'button_{nb}'].textContent = questions[index_question][f'Answer {nb}']
    else:
        final_print(CLIENT_PROFILE)

def button_clicked(ev):
    '''
    Changement de l'affichage et modification du profil lorsqu'on clique sur un bouton.
    On récupère l'id du bouton qui est cliqué avec l'objet pris en paramêtre ev.
    
    Entrées :
        - ev, paramètre par défaut et obligatoire pour les .bind()
    Sorties :
        - Pas de sortie, procédure d'affichage.
    '''
    global INDEX_QUESTION

    # Modification du profil client :
    nb_button_clicked = ev.target.id[-1:]
    added_values = questions_tab[INDEX_QUESTION][f'Value {nb_button_clicked}']

    # Pour les tests : document <= str(added_values)

    i = 0
    for caracteristic in CLIENT_PROFILE:
        if CLIENT_PROFILE[caracteristic] + added_values[i] > 0 and CLIENT_PROFILE[caracteristic] + added_values[i] < 9:
            CLIENT_PROFILE[caracteristic] += added_values[i]
        i += 1

    # Changement de l'affichage :
    INDEX_QUESTION += 1
    update_all(INDEX_QUESTION, questions_tab)

# Importation des questions :
questions_tab = csv_dict_import("Questions.csv")
for i in range(len(questions_tab)):
    for key in questions_tab[i]:
        if key in {"Value 1", "Value 2", "Value 3"}:
            questions_tab[i][key] = tuple_values(questions_tab[i][key])

# Création des éléments HTML :
create_all(questions_tab)

    
# .bind des boutons :
for nb in range(1, 4):
    document[f'button_{nb}'].bind("click", button_clicked)

'''
# Pour nos tests :
space(2)
document <= html.H4("Testez la questions / réponse à afficher :", id="test_questions")
for question in questions_tab:
    for key in question:
        document <= html.P(str(question[key]))
    space(2)
'''