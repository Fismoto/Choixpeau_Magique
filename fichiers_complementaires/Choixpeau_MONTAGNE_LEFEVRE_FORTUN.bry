# coding: utf_8

'''
Codé par : Octave FORTUN, Milo MONTAGNE, Pierrick LEFEVRE

Projet NSI 3 "Choixpeau Magique", partie II

IHM du Choixpeau Magique, utilise l'agorythme des KPPV codé précédemment.

Licence : CC-BY-NC-SA

github : https://github.com/Fismoto/Choixpeau_Magique
'''
# Importation des modules :
from math import sqrt
from browser import document, html
from kPPV_MONTAGNE_LEFEVRE_FORTUN import CARACTERISTICS, csv_dict_import, \
    euclidian_distance, knn_house, knn_str, poudlard_characters

# Variables globales :
CLIENT_PROFILE = {}
for caracteristic in CARACTERISTICS:
    CLIENT_PROFILE[caracteristic] = 0

INDEX_QUESTION = 0

ALL_ID = [] # Contiendra les id de tous les éléments html affichés sur le document

NB_SPACE = 0

K = 5

CHARACTERS = poudlard_characters


# Définition des fonctions (hors utilisation des boutons) :
def delete_all() -> None:
    '''
    Supprimme tous les éléments HTML de la page, et les supprimme de la liste ALL_ID.
    Pas d'entrée ni sortie (procédure).
    '''
    for id in ALL_ID:
        del document[id]

    ALL_ID.clear()


def ad_elt(content: str, id_elt: str, html_tag=html.P) -> None:
    '''
    Ajoute un élément HTML à la page Web et le référence dans la liste ALL_ID.
    Utile car dans le reste du programme, dès qu'on créera un élément html avec ad_elt()\
    son id sera automatiquement enregistré dans la liste ALL_ID.

    Entrées :
        - content, contenu de l'élément html à afficher dans le document
        - id_elt, id de l'élément ajouté
        - tag_type, balise html 
    '''
    # Préconditions :
    assert type(content) == str or type(content) == list , \
       "Le contenu à afficher doit être une chaîne de caractères ou une liste."

    assert type(id_elt) == str, \
       "L'id de l'élément html ajouté doit être entré sous forme de str."

    document <= html_tag(content, id=id_elt)
    ALL_ID.append(id_elt)

def space(nb_lines: int) -> None:
    '''
    Saute autant de lignes qu'indiqué en paramètre.

    Entrées :
        - nb_lines, entier positif
    Sorties :
        - pas de sorties (procédure d'affichage)
    '''
    # Préconditions:
    assert type(nb_lines) == int and nb_lines >= 0, \
        "On saute un nombre entier positif de lignes"

    global NB_SPACE

    for i in range(nb_lines):
        NB_SPACE += 1
        ad_elt(content='pas_de_texte', id_elt=f"space_{NB_SPACE}", html_tag=html.BR)
        # content ne sera pas affiché car on ajoute une balise <br>


# Affichage final :
def final_print(profile: dict, characters_data_base: list, k_client=K) -> None:
    '''
    Affichage final de la page (quand l'utilisateur clique sur le dernier bouton).
    Efface le contenu de la page et affiche la maison du personnage, en utilisant les KPPV

    Entrées :
        - profile : dictionnaire contenant les valeurs des caractéristiques de l'utilisateur
        - characters_data_base : table, liste de dictionnaires où chaque dictionnaire correspond à un personnage
        - k_client : entier, valeur par défault : la constante K


    Pas de sortie, procédure d'affichage
    '''
    # Préconditions :
    assert type(profile) == dict, \
        "Le nouveau personnage doit être sous forme de dictionnaire."

    assert type(characters_data_base) == list, \
        "La base de donnée des personnages doit être une liste de dictionnaires."

    assert type(k_client) == int and k_client > 0, \
        "Le k doit être un entier positif." 

    delete_all()    


    house, k_n_neighbors = knn_house(characters_data_base, profile, \
                                    CARACTERISTICS, k=k_client)

    # On crée une liste d'éléments de type <li> qui correspondent aux voisins :
    html_neighbors = []
    for neighbor in k_n_neighbors:
        neighbor_caracteristics = {}
        for caracteristic in CARACTERISTICS:
            neighbor_caracteristics[caracteristic] = neighbor[caracteristic]

        ngbr_print = f"{neighbor['Name']}, de la maison {neighbor['House']} "
        ngbr_print += f"ayant pour caractéristiques {neighbor_caracteristics}"

        html_neighbors.append(html.LI(ngbr_print))

    printed_elts = (("Bravo, vous avez répondu à toutes les questions !", html.H1), \
                    (f"Vos caractéristiques sont : {profile}", html.H3), \
                    ("Et votre maison est ...", html.H3), \
                    (house, html.H1), \
                    ("Vos k plus proches voisins sont :", html.H3), \
    # Les voisins seront affichés dans une balise de type <ul></ul> :
                    (html_neighbors, html.UL))

    i = 1
    for elt, tag in printed_elts:
        ad_elt(content=elt, id_elt=f"elt_{i}",html_tag=tag)
        i += 1


def new_k(ev) -> None:
    '''
    Fonction appellée quand on clique sur le bouton 'change_k_button' 
    (voir def end_of_quizz())
    Appelle la fonction final_print() avec le nouveau k.

    Entrées :
        - ev, paramètre obligatoire pour le .bind() du bouton

    Pas de sorties, procédure d'affichage.
    '''
    global K

    K = int(input("Saisissez un nouveau k sous forme d'entier positif : "))
    final_print(profile=CLIENT_PROFILE, characters_data_base=CHARACTERS, \
                k_client=K)

    # Pour que l'utilisateur puisse à nouveau changer k :

    ad_elt(content="Changer la valeur de k", id_elt="change_k_button", \
            html_tag=html.BUTTON)
    
    document["change_k_button"].bind('click', new_k)


def end_of_quizz() -> None:
    '''
    Fonction appellée quand le dernier bouton est cliqué, 
    lance l'affichage final final_print()
    Pas d'entrées ni sorties, procédure d'affichage.
    '''
    final_print(profile=CLIENT_PROFILE, characters_data_base=CHARACTERS, \
                k_client=K)

    ad_elt(content="Changer la valeur de k", id_elt='change_k_button', \
            html_tag=html.BUTTON)
    
    document["change_k_button"].bind('click', new_k)


# Définition des fonctions liées aux boutons :
def bind_buttons(buttons: list, function, event='click') -> None:
    '''
    .bind() des 3 boutons réponses, en une fonction.

    Entrées : 
        - buttons : liste ou tuple, contient les id des boutons à .bind()
        - function : fonction appellée lors de l'évènement event (pris en paramètre)
        - event : chaîne de caractères, 
            évènement qui appelle la fonction function (prise en paramètre)

    Pas de sortie, procédure Web
    '''
    # Préconditions:
    assert type(buttons) == list or type(buttons) == tuple, \
        "Les boutons à .bind() doivent être entrés sous forme de liste ou de tuple."
    assert type(event) == str, \
        "L'évènement doit être une chaîne de caractères (ex : 'click')"

    for nb in range(1, 4):
        document[f'button_{nb}'].bind(event, function)


def create_quizz(questions: list, function_called) -> None:
    '''
    Crée tous les éléments HTML du questionnaire.

    Entrées :
        - questions, liste de dictionnaires 
        où chaque dictionnaire correspond à une question 
        et est de la forme : {'Question': 'question', \
                            'Answer 1': 'réponse', 'Value 1': 'tuple_de_valeurs', \
                            'Answer 2': 'réponse', 'Value 2': 'tuple_de_valeurs', \
                            'Answer 2': 'réponse', 'Value 2': 'tuple_de_valeurs'}

        - function_called : fonction appellée au clic des boutons

    Pas de sortie, procédure d'affichage.
    '''
    question = "Question 1 : " + questions[INDEX_QUESTION]['Question']
    ad_elt(content=question, id_elt='printed_question', html_tag=html.H2)

    response_buttons = [f"button_{i}" for i in range(1, 4)]
    for i in range(3):
        ad_elt(questions[INDEX_QUESTION][f'Answer {i + 1}'], \
            id_elt=response_buttons[i], html_tag=html.BUTTON)            
        space(2)

    bind_buttons(response_buttons, function=function_called, event='click')

    ad_elt(content=f"1/{len(questions)}", id_elt='counter', html_tag=html.P)

def tuple_values(values : str) -> tuple:
    '''
    Transforme un str en tuple (pour l'import des questions)
    Entrées :
        - values, str de la forme "0, -1, +2, +1"
    Sorties :
        - tuple de la forme (0, -1, 2, 1)
    '''
    # Préconditions:
    assert type(values) == str, "L'entrée de la fonction doit être un str."
    
    list_values = []
    for number in values.split(', '):
        list_values.append(int(number))
    return tuple(list_values)


# Importation des questions :
QUESTIONS_TAB = csv_dict_import("fichiers_complementaires/Questions.csv")
for i in range(len(QUESTIONS_TAB)):
    for key in QUESTIONS_TAB[i]:
        if key in {"Value 1", "Value 2", "Value 3"}:
            QUESTIONS_TAB[i][key] = tuple_values(QUESTIONS_TAB[i][key])
# (On est obligé de mettre cette table en variable globale pour l'utiliser dans la fonction button_clicked)


def update_quizz(questions: int, characters_data_base: int, k=K) -> None:
    '''
    Met à jour l'affichage de la question et des boutons
    
    Entrées :
        - questions : table des questions à afficher
        - characters_data_base : table des personnages, pour les KPPV
        - k : entier positif, nombre de plus proches voisins 
            utilisés pour le choix de la maison
    
    Pas de sorties, procédure d'affichage.
    '''
    # Préconditions :
    assert type(questions) == list and type(characters_data_base) == list, \
        "Les questions et la base de donnée des personnages \
        doivent être entrées sous la forme d'une liste de dictionnaires"

    assert type(k) == int and k > 0, "k est un entier strictement positif"

    global INDEX_QUESTION
    INDEX_QUESTION += 1

    if INDEX_QUESTION < len(questions): # Il reste au moins une question à afficher
        question = f"Question {INDEX_QUESTION + 1} : " \
                    + questions[INDEX_QUESTION]['Question']

        document['printed_question'].textContent = question

        for nb in range(1, 4):
            document[f'button_{nb}'].textContent = questions[INDEX_QUESTION][f'Answer {nb}']

        document['counter'].textContent = str(INDEX_QUESTION + 1) + "/" + str(len(questions))

    else: # L'utilisateur a déjà répondu à toutes les questions
        end_of_quizz()


def response_button_clicked(ev) -> None:
    '''
    Changement de l'affichage et modification du profil lorsqu'on clique sur un bouton.
    On récupère l'id du bouton qui est cliqué avec l'objet pris en paramêtre ev.
    
    Entrées :
        - ev, paramètre par défaut et obligatoire pour les .bind()
    Sorties :
        - Pas de sortie, procédure d'affichage.
    '''  

    # Modification du profil client :

    nb_button_clicked = ev.target.id[-1:]
    added_values = QUESTIONS_TAB[INDEX_QUESTION][f'Value {nb_button_clicked}']

    for i, caracteristic in enumerate(CLIENT_PROFILE):
        if CLIENT_PROFILE[caracteristic] + added_values[i] > 0 and CLIENT_PROFILE[caracteristic] + added_values[i] < 9:
            CLIENT_PROFILE[caracteristic] += added_values[i]

    # Changement de l'affichage :
    update_quizz(questions=QUESTIONS_TAB, characters_data_base=CHARACTERS, k=K)


def launch_quizz(ev) -> None:
    '''
    Supprimme tout le contenu de la page
    puis lance le questionnaire.

    Entrées :
        - ev, paramètre par défaut et obligatoire pour les .bind()
    Sorties :
        - Pas de sortie, procédure d'affichage.
    '''
    delete_all()

    create_quizz(questions=QUESTIONS_TAB, function_called=response_button_clicked)


def page_beginning() -> None:
    '''
    Premier affichage de la page, 
    création d'un bouton qui appelle la fonction launch_quizz().

    Pas d'entrée ni sortie, procédure d'affichage.
    '''
    first_sentences = ("Salut, jeune bipède, aurais-tu quelques minutes à m'accorder ?", \
        "Je suis le choixpeau magique, répond à mes questions et tu connaitras ta maison !")    

    for i in range(len(first_sentences)):
        ad_elt(content=first_sentences[i], id_elt=f'sentence_{i + 1}', html_tag=html.H1)

    ad_elt(content="C'est parti !", id_elt='first_button', html_tag=html.BUTTON)
    document['first_button'].bind("click", launch_quizz)


# Affichage de la page :
page_beginning()